
/* Formatting Dates */
SELECT FORMAT(GETDATE(), 'd ''of'' MMMM') + ' is my birthday' AS Birthday;

SELECT FORMAT(GETDATE(), 'd''st'' ''of'' MMMM') + ' is my birthday' AS Birthday;

SELECT FORMAT(GETDATE(), 'dd MM yyyy') + ' is my birthday' AS Birthday;

SELECT FORMAT(GETDATE(), 'yyyy') + ' is my birthday' AS Birthday;

SELECT FORMAT(GETDATE(), 'MMMM') + ' is my birthday' AS Birthday;

/* Formatting Numbers */
SELECT FORMAT(SALARY, '$#,##0.00') AS SALARY
FROM EMPLOYEES;

/* Activities for Date Functions */
/* Activity 1: Format hire date as "01-Jan-2022" */
SELECT LAST_NAME, FORMAT(HIRE_DATE, 'dd-MMM-yyyy') AS FormattedHireDate
FROM EMPLOYEES;

/* Activity 2: Format hire date as "1st of Jan 2022" */
SELECT LAST_NAME, 
       FORMAT(HIRE_DATE, 'd''th'' ''of'' MMM yyyy') AS FormattedHireDate
FROM EMPLOYEES;

/* More Activities for Date and String Functions */
/* Activity 1: Envelope printing with name length restriction */
SELECT FIRST_NAME, LAST_NAME,
       CASE 
           WHEN LEN(FIRST_NAME + ' ' + LAST_NAME) > 15 
           THEN LEFT(FIRST_NAME, 1) + ' ' + LEFT(LAST_NAME, 14)
           ELSE FIRST_NAME + ' ' + LAST_NAME
       END AS Addressee
FROM EMPLOYEES
WHERE LEN(FIRST_NAME + ' ' + LAST_NAME) > 15;

/* Activity 2: Employee tenure and review dates */
SELECT EMPLOYEE_ID, HIRE_DATE,
       DATEDIFF(MONTH, HIRE_DATE, GETDATE()) AS MonthsEmployed,
       DATEADD(MONTH, 6, HIRE_DATE) AS SixMonthReview,
       DATEADD(DAY, 
               (6 - DATEPART(WEEKDAY, HIRE_DATE) + 7) % 7, 
               HIRE_DATE) AS FirstFriday,
       EOMONTH(HIRE_DATE) AS LastDayOfHireMonth
FROM EMPLOYEES
WHERE DATEDIFF(MONTH, HIRE_DATE, GETDATE()) < 150
AND DEPARTMENT_ID = 50;

/* Nesting Functions */
/* Combine functions for complex transformations */
SELECT LAST_NAME, UPPER(FIRST_NAME + JOB_ID) AS EmployeeInfo
FROM EMPLOYEES;

/* NULL Handling Functions */
SELECT LAST_NAME, SALARY, COMMISSION_PCT, 
       ISNULL(COMMISSION_PCT, 0) AS Commission,
       SALARY + 10 + ISNULL(COMMISSION_PCT, 0) AS TotalPay
FROM EMPLOYEES;

/* Using IIF for Conditional Logic */
SELECT LAST_NAME, SALARY, COMMISSION_PCT, 
       IIF(COMMISSION_PCT IS NOT NULL, 'SAL+COMM', 'SAL') AS INCOME
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (60, 80, 90);

/* Using NULLIF */
SELECT FIRST_NAME, LEN(FIRST_NAME) AS EXPR1, 
       LAST_NAME, LEN(LAST_NAME) AS EXPR2, 
       NULLIF(LEN(FIRST_NAME), LEN(LAST_NAME)) AS RESULT
FROM EMPLOYEES;

/* Using COALESCE */
SELECT LAST_NAME, FIRST_NAME, SALARY, COMMISSION_PCT,
       COALESCE(SALARY + (COMMISSION_PCT * SALARY), SALARY + 2000, SALARY) AS [NEW SALARY]
FROM EMPLOYEES;

/* COALESCE with String Conversion */
SELECT LAST_NAME, COMMISSION_PCT, MANAGER_ID,
       COALESCE(CAST(COMMISSION_PCT AS VARCHAR), CAST(MANAGER_ID AS VARCHAR)) AS [NO COMMISSION AND MANAGER]
FROM EMPLOYEES;

/* Conditional Expressions */
SELECT LAST_NAME, JOB_ID, SALARY,
       CASE JOB_ID 
           WHEN 'IT_PROG' THEN (0.10 * SALARY) + SALARY
           WHEN 'SA_REP' THEN (0.20 * SALARY) + SALARY
           WHEN 'ST_CLERK' THEN (0.05 * SALARY) + SALARY
           ELSE SALARY 
       END AS [REVISED SALARY]
FROM EMPLOYEES;

/* CASE with Range Conditions */
SELECT SALARY, LAST_NAME,
       CASE 
           WHEN SALARY <= 10000 THEN 'LOW'
           WHEN SALARY BETWEEN 10001 AND 20000 THEN 'AVG'
           WHEN SALARY >= 20000 THEN 'HIGH'
           ELSE 'UNKNOWN'
       END AS SALARY_LEVEL
FROM EMPLOYEES;

/* Activities for Conditional Expressions */
/* Activity 1: Compare name lengths for DEPARTMENT_ID 100 */
SELECT LAST_NAME, FIRST_NAME,
       CASE 
           WHEN LEN(FIRST_NAME) = LEN(LAST_NAME) THEN 'Same Length'
           ELSE 'Different Length'
       END AS NAME_LENGTHS
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100;

/* Activity 2: Location info based on STATE_PROVINCE */
SELECT CITY, STATE_PROVINCE,
       CASE STATE_PROVINCE
           WHEN 'Washington' THEN 'Headquarters'
           WHEN 'Texas' THEN 'Oil Wells'
           WHEN 'California' THEN 'City'
           WHEN 'New Jersey' THEN 'Street Address'
           ELSE 'Other'
       END AS LOCATION_INFO
FROM LOCATIONS
WHERE COUNTRY_ID = 'US'
ORDER BY LOCATION_INFO;

/* GROUP & AGGREGATION FUNCTIONS */
/* GROUP FUNCTIONS IGNORE NULL VALUES */
/* AVG, COUNT, DISTINCT, SUM, MIN, MAX */

/* 1. Average, Max, and Min Salary for Employees with Job IDs containing 'REP' */
SELECT ROUND(AVG(SALARY), 0) AS AvgSalary, MAX(SALARY) AS MaxSalary, MIN(SALARY) AS MinSalary
FROM EMPLOYEES
WHERE JOB_ID LIKE '%REP%';

/* 2. Earliest and Latest Hire Dates */
SELECT MIN(HIRE_DATE) AS EarliestHire, MAX(HIRE_DATE) AS LatestHire
FROM EMPLOYEES;

/* 3. Count of Employees in Department 80 */
SELECT COUNT(*) AS EmployeeCount
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 80;

/* 4. Count of Employees with Commission in Department 80 */
SELECT COUNT(COMMISSION_PCT) AS CommissionCount
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 80;

/* 5. Display All Employees in Department 100 */
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100;

/* 6. Average Commission (Ignores NULLs) */
SELECT AVG(COMMISSION_PCT) AS AvgCommission
FROM EMPLOYEES;

/* 7. Average Commission, Treating NULLs as 0 */
SELECT AVG(ISNULL(COMMISSION_PCT, 0)) AS AvgCommissionWithNulls
FROM EMPLOYEES;

/* 8. Count of Distinct Department IDs */
SELECT COUNT(DISTINCT DEPARTMENT_ID) AS DistinctDepartments
FROM EMPLOYEES;

/* 9. List Distinct Department IDs */
SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES;

/* 10. Count of Employees with Commission */
SELECT COUNT(COMMISSION_PCT) AS CommissionCount
FROM EMPLOYEES;

SELECT DEPARTMENT_ID, AVG(SALARY) AS AvgSalary, MIN(SALARY) AS MinSalary, 
MAX(SALARY) AS MaxSalary
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID

/* 11. Aggregate Salaries by Department, Ordered by Max Salary */
SELECT DEPARTMENT_ID, AVG(SALARY) AS AvgSalary, MIN(SALARY) AS MinSalary, MAX(SALARY) AS MaxSalary
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY MAX(SALARY) DESC;

/* 13. Aggregate Salaries for Specific Job IDs, Ordered by Max Salary */
SELECT DEPARTMENT_ID, AVG(SALARY) AS AvgSalary, MIN(SALARY) AS MinSalary, MAX(SALARY) AS MaxSalary
FROM EMPLOYEES
WHERE JOB_ID IN ('AD_VP', 'AD_PRES', 'IT_PROG')
GROUP BY DEPARTMENT_ID
ORDER BY MAX(SALARY) DESC;

/* 14. Illegal Query: Cannot Use Aggregate in WHERE */
/* Violation: Aggregate functions like AVG cannot be used in WHERE clause */
-- This will fail
SELECT DEPARTMENT_ID, AVG(SALARY) AS AvgSalary, MIN(SALARY) AS MinSalary, MAX(SALARY) AS MaxSalary
FROM EMPLOYEES
WHERE AVG(SALARY) > 10000
GROUP BY DEPARTMENT_ID
ORDER BY MAX(SALARY) DESC;

/* 15. Corrected Query: Use HAVING for Aggregate Filtering */
SELECT DEPARTMENT_ID, JOB_ID, ROUND(AVG(SALARY), 2) AS AvgSalary, MIN(SALARY) AS MinSalary, MAX(SALARY) AS MaxSalary
FROM EMPLOYEES
WHERE JOB_ID IN ('AD_VP', 'AD_PRES', 'IT_PROG')
GROUP BY DEPARTMENT_ID, JOB_ID
HAVING AVG(SALARY) > 10000
ORDER BY MAX(SALARY) DESC;

/* 16. Top 10 Employees (Replaces ROWNUM) */
SELECT TOP 10 *
FROM EMPLOYEES;

/* 18. Calculate Total Salary (CTC) Using Window Function */
SELECT SALARY, DEPARTMENT_ID, SUM(SALARY) OVER () AS "CTC"
FROM EMPLOYEES;

/*19. USING PARTITION BY */
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID, 
SUM(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS DEPTWISETOTSAL
FROM EMPLOYEES

/*20 Row_number (1,2,3), rank (1,1,3),  dense rank(1,1,2) */

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, ROW_NUMBER() OVER (ORDER BY SALARY DESC) 
AS ROWNUM, RANK() OVER (ORDER BY SALARY DESC) AS RNK, 
DENSE_RANK() OVER (ORDER BY SALARY DESC) AS DRNK
FROM EMPLOYEES

/* NTILE,LEAD,LAG */

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, NTILE (4) OVER (ORDER BY SALARY DESC)
AS SAL_QUARTILES
FROM EMPLOYEES

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, LEAD(SALARY) OVER (ORDER BY EMPLOYEE_ID DESC)
AS LD
FROM EMPLOYEES

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, LAG(SALARY) OVER (ORDER BY EMPLOYEE_ID DESC)
AS LG
FROM EMPLOYEES

/* ACTIVITIES */

/* Activity 1: Days of the Week with 2 or More Hires */
SELECT DATENAME(WEEKDAY, HIRE_DATE) AS HireDay, COUNT(*) AS HireCount
FROM EMPLOYEES
GROUP BY DATENAME(WEEKDAY, HIRE_DATE)
HAVING COUNT(*) >= 2
ORDER BY HireCount DESC;

/* Activity 2: Staff Turnover by Year and Job ID */
SELECT YEAR(END_DATE) AS EndYear, JOB_ID, COUNT(*) AS TurnoverCount
FROM EMPLOYEES
WHERE END_DATE IS NOT NULL
GROUP BY YEAR(END_DATE), JOB_ID
ORDER BY TurnoverCount DESC;

/* Activity 3: Average Length of Country Names (Assuming Countries Table Exists) */
/* Note: LOCATIONS has COUNTRY_ID, but we need a COUNTRIES table for names */
-- If COUNTRIES table exists with COUNTRY_NAME:
-- SELECT ROUND(AVG(LEN(COUNTRY_NAME)), 0) AS AvgCountryNameLength
-- FROM COUNTRIES;
-- Since COUNTRIES table isn't defined, we'll simulate using CITY in LOCATIONS:
SELECT ROUND(AVG(LEN(CITY)), 0) AS AvgCityNameLength
FROM LOCATIONS;

/* JOINS & SUBQUERIES */
/* PURE NATURAL JOINS, USING CLAUSE, ON, OUTER JOINS */

/* 1. Simplest INNER JOIN Without Aliases (Replaces NATURAL JOIN) */
/* Purpose: Combine DEPARTMENTS and LOCATIONS to show department details and city */

SELECT DEPARTMENTS.DEPARTMENT_ID, DEPARTMENTS.DEPARTMENT_NAME, DEPARTMENTS.LOCATION_ID, LOCATIONS.CITY
FROM DEPARTMENTS
INNER JOIN LOCATIONS
ON DEPARTMENTS.LOCATION_ID = LOCATIONS.LOCATION_ID;

/* 2. Same INNER JOIN with Aliases (Old Comma-Separated Syntax) */
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, D.LOCATION_ID, L.CITY
FROM DEPARTMENTS D, LOCATIONS L
WHERE D.LOCATION_ID = L.LOCATION_ID;

/* 3. INNER JOIN with Filtering (No Aliases) */
SELECT DEPARTMENTS.DEPARTMENT_ID, DEPARTMENTS.DEPARTMENT_NAME, DEPARTMENTS.LOCATION_ID, LOCATIONS.CITY
FROM DEPARTMENTS
INNER JOIN LOCATIONS
ON DEPARTMENTS.LOCATION_ID = LOCATIONS.LOCATION_ID
WHERE DEPARTMENTS.DEPARTMENT_ID IN (60, 90, 100);

/* 4. INNER JOIN with ON Clause (No Aliases) */
/* Purpose: Join EMPLOYEES and DEPARTMENTS on DEPARTMENT_ID */
/* Note: SQL Server does not reliably support USING; we use ON instead */
SELECT *
FROM EMPLOYEES
JOIN DEPARTMENTS
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
WHERE EMPLOYEES.DEPARTMENT_ID = 80;

/* 5. INNER JOIN with ON Clause and Aliases */
/* Purpose: Show how to use ON with aliases; columns not in the join condition (e.g., MANAGER_ID) should be aliased if they exist in both tables to avoid ambiguity */
SELECT E.LAST_NAME, E.DEPARTMENT_ID, D.MANAGER_ID
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.DEPARTMENT_ID = 80;

/* 6. Violation: Ambiguity Without Proper Aliasing */
/* Note: This demonstrates a potential mistake if columns are not properly aliased; 
however, since MANAGER_ID exists in both tables, we must specify the source */
SELECT E.LAST_NAME, E.DEPARTMENT_ID, D.MANAGER_ID
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE DEPARTMENT_ID = 80;  -- This is fine since DEPARTMENT_ID is specified in the join condition

/* 7. Corrected: Consistent Aliasing for Clarity */
/* Purpose: Reinforce proper aliasing for columns in both tables */
SELECT E.LAST_NAME, E.DEPARTMENT_ID, D.MANAGER_ID
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.DEPARTMENT_ID = 80;

/* 8. INNER JOIN with ON Clause (No Aliases) */
/* Purpose: Combine EMPLOYEES and DEPARTMENTS to show employee names and department names */
SELECT EMPLOYEES.LAST_NAME, DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES
INNER JOIN DEPARTMENTS
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

/* 9. Same INNER JOIN with Aliases */
SELECT E.LAST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

/* 10. Highlighting the Importance of ON in SQL Server */
/* Note: In other databases like Oracle, USING can simplify joins, 
but SQL Server requires ON for reliable joins */
SELECT E.LAST_NAME, E.DEPARTMENT_ID, E.MANAGER_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

/* 11. Why Avoid NATURAL JOIN (Not Supported in SQL Server) */
/* Rule: SQL Server requires explicit JOIN syntax; NATURAL JOIN is ambiguous and not supported */
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, L.LOCATION_ID, L.CITY
FROM DEPARTMENTS D
INNER JOIN LOCATIONS L 
ON D.LOCATION_ID = L.LOCATION_ID;

/* 12. Join with Filtering (With Aliases) */
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, L.LOCATION_ID, L.CITY
FROM DEPARTMENTS D
INNER JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID
WHERE D.DEPARTMENT_ID IN (50, 60, 80);

/* 13. Multiple Joins */
SELECT E.EMPLOYEE_ID, E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME, L.LOCATION_ID, L.CITY
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID;

/* 14. Self Join */
SELECT E.FIRST_NAME, E.LAST_NAME, MGR.FIRST_NAME AS MgrFirstName,
MGR.LAST_NAME AS MgrLastName
FROM EMPLOYEES E
JOIN EMPLOYEES MGR
ON E.MANAGER_ID = MGR.EMPLOYEE_ID;

SELECT * FROM EMPLOYEES

/* 15. Non-Equi Join */
SELECT E.LAST_NAME, E.SALARY, J.JOB_TITLE
FROM EMPLOYEES E
JOIN JOBS J
ON E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY;

/* 16. Cross Join */
SELECT E.EMPLOYEE_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
CROSS JOIN DEPARTMENTS D;

/* 17. Outer Joins */
SELECT E.LAST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT E.LAST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT E.LAST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
FULL OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

/* Activities for Joins */
SELECT E.EMPLOYEE_ID, E.JOB_ID, E.DEPARTMENT_ID, E.LAST_NAME, E.HIRE_DATE, E.END_DATE
FROM EMPLOYEES E
INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT E.FIRST_NAME + ' ' + E.LAST_NAME + ' is manager of the ' + D.DEPARTMENT_NAME AS Managers
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON D.MANAGER_ID = E.EMPLOYEE_ID;

SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM DEPARTMENTS D
LEFT OUTER JOIN EMPLOYEES E
ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE E.EMPLOYEE_ID IS NULL;

SELECT E.LAST_NAME, E.EMPLOYEE_ID, M.LAST_NAME AS ManagerLastName, E.DEPARTMENT_ID
FROM EMPLOYEES E
JOIN EMPLOYEES M
ON E.MANAGER_ID = M.EMPLOYEE_ID
WHERE E.DEPARTMENT_ID IN (10, 20, 30)
ORDER BY E.DEPARTMENT_ID;

/* SUBQUERIES */
/* Single-Row Subquery */
SELECT MAX(SALARY) AS MaxSalary
FROM EMPLOYEES;

/* Nested Subquery: Second Highest Salary */
SELECT MAX(SALARY) AS SecondHighest
FROM EMPLOYEES
WHERE SALARY < (SELECT MAX(SALARY) FROM EMPLOYEES);

/* Nested Subquery: Third Highest Salary */
SELECT MAX(SALARY) AS ThirdHighest
FROM EMPLOYEES
WHERE SALARY < (SELECT MAX(SALARY)
                FROM EMPLOYEES
                WHERE SALARY < (SELECT MAX(SALARY) FROM EMPLOYEES));


/* Violation: Incorrect Ordering with Row Limiting */
/* Rule: TOP Applies Before ORDER BY in SQL Server */
-- This will fail to give correct results without proper subquery
SELECT *
FROM EMPLOYEES
WHERE ROW_NUMBER() OVER (ORDER BY SALARY DESC) <= 5;

/* Correct Code: Use TOP with ORDER BY */
SELECT TOP 5 *
FROM EMPLOYEES
ORDER BY SALARY DESC;

/* Subquery with ANY */
SELECT LAST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE SALARY < ANY (SELECT SALARY FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG')
AND JOB_ID <> 'IT_PROG';

/* Subquery with ALL */
SELECT LAST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE SALARY < ALL (SELECT SALARY FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG')
AND JOB_ID <> 'IT_PROG';

/* Subquery with EXISTS */
SELECT EMPLOYEE_ID, SALARY, LAST_NAME
FROM EMPLOYEES E
WHERE EXISTS
(SELECT EMPLOYEE_ID FROM EMPLOYEES E1
WHERE E1.MANAGER_ID = E.EMPLOYEE_ID
AND E1.SALARY > 10000);

/* Subquery with NOT EXISTS */
SELECT DEPARTMENT_ID, DEPARTMENT_NAME
FROM DEPARTMENTS D
WHERE NOT EXISTS
(SELECT * FROM EMPLOYEES E
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID);

/* Subquery with NOT IN */
SELECT E.LAST_NAME
FROM EMPLOYEES E
WHERE E.EMPLOYEE_ID NOT IN 
(SELECT MGR.MANAGER_ID FROM EMPLOYEES MGR WHERE MGR.MANAGER_ID IS NOT NULL);

/* Activities for Subqueries */
SELECT E1.LAST_NAME
FROM EMPLOYEES E1
WHERE EXISTS
(SELECT * FROM EMPLOYEES E2 WHERE E2.MANAGER_ID = E1.EMPLOYEE_ID);

SELECT L.COUNTRY_ID, MAX(E.SALARY) AS MaxSalary
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
GROUP BY L.COUNTRY_ID;